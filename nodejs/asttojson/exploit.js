const fs = require('fs');

// 手動還原 AST 的函數（處理不完整的 AST）
function restoreAST(node, indent = 0) {
    if (!node || typeof node !== 'object') {
        return String(node || '');
    }

    const ind = '  '.repeat(indent);
    const type = node.type;

    try {
        switch (type) {
            case 'Program':
                return node.body.map(stmt => restoreAST(stmt, indent)).join('\n');

            case 'ExpressionStatement':
                return restoreAST(node.expression, indent) + ';';

            case 'CallExpression':
                const callee = restoreAST(node.callee, indent);
                const args = (node.arguments || []).map(arg => restoreAST(arg, indent)).join(', ');
                return `${callee}(${args})`;

            case 'ArrowFunctionExpression':
            case 'FunctionExpression':
                const params = (node.params || []).map(p => restoreAST(p, indent)).join(', ');
                const body = restoreAST(node.body, indent);
                return `(${params}) => ${body}`;

            case 'BlockStatement':
                const stmts = (node.body || []).map(stmt => ind + '  ' + restoreAST(stmt, indent + 1)).join('\n');
                return `{\n${stmts}\n${ind}}`;

            case 'VariableDeclaration':
                const kind = node.kind || 'let';
                const decls = (node.declarations || []).map(d => restoreAST(d, indent)).join(', ');
                return `${kind} ${decls}`;

            case 'VariableDeclarator':
                const id = restoreAST(node.id, indent);
                if (node.init) {
                    return `${id} = ${restoreAST(node.init, indent)}`;
                }
                return id;

            case 'Identifier':
                return node.name || '';

            case 'Literal':
                if (typeof node.value === 'string') {
                    return `"${node.value}"`;
                }
                return String(node.value);

            case 'ArrayExpression':
                const elements = (node.elements || []).map(el => restoreAST(el, indent)).join(', ');
                return `[${elements}]`;

            case 'ObjectExpression':
                const props = (node.properties || []).map(p => restoreAST(p, indent)).join(', ');
                return `{${props}}`;

            case 'Property':
                const key = restoreAST(node.key, indent);
                const value = restoreAST(node.value, indent);
                return `${key}: ${value}`;

            case 'MemberExpression':
                const obj = restoreAST(node.object, indent);
                const prop = restoreAST(node.property, indent);
                if (node.computed) {
                    return `${obj}[${prop}]`;
                }
                return `${obj}.${prop}`;

            case 'AssignmentExpression':
                const left = restoreAST(node.left, indent);
                const right = restoreAST(node.right, indent);
                const op = node.operator || '=';
                return `${left} ${op} ${right}`;

            case 'BinaryExpression':
            case 'LogicalExpression':
                const binLeft = restoreAST(node.left, indent);
                const binRight = restoreAST(node.right, indent);
                const binOp = node.operator || '+';
                return `${binLeft} ${binOp} ${binRight}`;

            case 'UnaryExpression':
                const arg = restoreAST(node.argument, indent);
                const prefix = node.prefix !== false;
                if (prefix) {
                    return `${node.operator}${arg}`;
                }
                return `${arg}${node.operator}`;

            case 'ConditionalExpression':
                const test = restoreAST(node.test, indent);
                const cons = restoreAST(node.consequent, indent);
                const alt = restoreAST(node.alternate, indent);
                return `${test} ? ${cons} : ${alt}`;

            case 'ReturnStatement':
                if (node.argument) {
                    return `return ${restoreAST(node.argument, indent)}`;
                }
                return 'return';

            case 'IfStatement':
                const ifTest = restoreAST(node.test, indent);
                const ifCons = restoreAST(node.consequent, indent);
                let result = `if (${ifTest}) ${ifCons}`;
                if (node.alternate) {
                    result += ` else ${restoreAST(node.alternate, indent)}`;
                }
                return result;

            case 'ForStatement':
                const forInit = node.init ? restoreAST(node.init, indent) : '';
                const forTest = node.test ? restoreAST(node.test, indent) : '';
                const forUpdate = node.update ? restoreAST(node.update, indent) : '';
                const forBody = restoreAST(node.body, indent);
                return `for (${forInit}; ${forTest}; ${forUpdate}) ${forBody}`;

            case 'WhileStatement':
                const whileTest = restoreAST(node.test, indent);
                const whileBody = restoreAST(node.body, indent);
                return `while (${whileTest}) ${whileBody}`;

            case 'UpdateExpression':
                const updateArg = restoreAST(node.argument, indent);
                if (node.prefix) {
                    return `${node.operator}${updateArg}`;
                }
                return `${updateArg}${node.operator}`;

            case 'SequenceExpression':
                const exprs = (node.expressions || []).map(e => restoreAST(e, indent)).join(', ');
                return `(${exprs})`;

            default:
                console.warn(`未知的節點類型: ${type}`);
                return `/* 未知節點: ${type} */`;
        }
    } catch (error) {
        console.error(`處理節點時出錯 (${type}):`, error.message);
        return `/* 錯誤: ${type} */`;
    }
}

// 主程序
try {
    // 讀取 AST JSON
    const astData = JSON.parse(fs.readFileSync('ast.json', 'utf-8'));

    console.log('AST 結構:');
    console.log(JSON.stringify(astData, null, 2).substring(0, 500) + '...\n');

    // 還原代碼
    const restoredCode = restoreAST(astData);

    console.log('還原的代碼:');
    console.log('='.repeat(50));
    console.log(restoredCode);
    console.log('='.repeat(50));

    // 儲存結果
    fs.writeFileSync('restored.js', restoredCode, 'utf-8');
    console.log('\n✓ 已儲存到 restored.js');

} catch (error) {
    console.error('錯誤:', error.message);
    console.error('\n請確認:');
    console.error('1. ast.json 文件存在');
    console.error('2. JSON 格式正確');
    console.error('3. 文件編碼為 UTF-8');
}